#!/usr/bin/env python
import functools
import os
import shutil
import subprocess
import sys
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Any, Iterator, List, NoReturn, Optional

import jinja2
import typer
from pydantic import BaseModel, ValidationError
from ruamel.yaml import YAML  # type: ignore

cli = typer.Typer(add_completion=False)


@dataclass
class Dirs:
    root: Path
    web: Path
    build: Path

    @classmethod
    def from_env(cls) -> "Dirs":
        root = Path(os.environ["PROJECT_ROOT"])
        return cls(root=root, web=root / "web", build=root / "ignore" / "dist")


class FrontMatter(BaseModel):
    url: str


class Page(BaseModel):
    path: Path
    front_matter: FrontMatter
    template: str


class Link(BaseModel):
    text: str
    url: str


class Speaker(BaseModel):
    name: str
    affiliation: str
    bio: str
    photo_url: str
    external_urls: List[Link]


class Talk(BaseModel):
    title: str
    subtitle: str
    speaker: Speaker
    abstract: str
    keywords: str


class EventType(Enum):
    MEETUP = "meetup"


class Event(BaseModel):
    title: str
    type: EventType
    description: str
    talks: List[Talk]
    date: str
    start_time: str
    location: Link
    meetup_url: str
    published: bool

    @property
    def title_escaped(self) -> str:
        return self.title.lower().replace(" ", "-")

    @property
    def url(self) -> str:
        return f"/events/{self.date}/{self.title_escaped}"

    @property
    def index_file(self) -> Path:
        return Path("events") / self.date / self.title_escaped / "index.html"


class State(BaseModel):
    events: List[Event]


def load(dirs: Dirs, template_name: str) -> Optional[str]:
    template_file = dirs.web / "templates" / template_name
    if template_file.exists():
        return template_file.read_text()
    else:
        return None


def yaml_decode(val: str) -> Any:
    return YAML(typ="base").load(val)


def iter_pages(dirs: Dirs) -> Iterator[Page]:
    for path in (dirs.web / "pages").iterdir():
        front_matter_yaml, template = path.read_text().split("===")

        try:
            front_matter = FrontMatter.parse_obj(
                yaml_decode(front_matter_yaml)
            )
        except ValidationError as e:
            show_validation_error(path.relative_to(dirs.root), e)

        # noinspection PyUnboundLocalVariable
        yield Page(path=path, front_matter=front_matter, template=template)


def load_state(dirs: Dirs) -> State:
    events_file = dirs.root / "events.yaml"
    try:
        return State.parse_obj(yaml_decode(events_file.read_text()))
    except ValidationError as e:
        show_validation_error(events_file.relative_to(dirs.root), e)


def show_validation_error(filename: Path, error: ValidationError) -> NoReturn:
    print(f"{filename}: Problems found")
    print(error)
    sys.exit(1)


@cli.command()
def site() -> None:
    """Build the site"""
    print("Building..")

    dirs = Dirs.from_env()

    shutil.rmtree(dirs.build, ignore_errors=True)
    dirs.build.mkdir(exist_ok=True, parents=True)

    for static in {"style.css", "logo.svg", "sitemap.xml", "robots.txt"}:
        shutil.copy(dirs.web / static, dirs.build)

    for directory in {"img", "font"}:
        shutil.copytree(dirs.web / directory, dirs.build / directory)

    load_fun = functools.partial(load, dirs)
    jinja_env = jinja2.Environment(loader=jinja2.FunctionLoader(load_fun))

    state = load_state(dirs)
    published_events = [e for e in state.events if e.published]

    for page in iter_pages(dirs):
        url = page.front_matter.url
        url_dir = dirs.build / url.lstrip("/")
        url_index_file = url_dir / "index.html"

        url_dir.mkdir(exist_ok=True)
        rendered = jinja_env.from_string(page.template).render(
            events=published_events, active_page=url
        )
        url_index_file.write_text(rendered)

    for event in published_events:
        event_index_file = dirs.build / event.index_file
        event_index_file.parent.mkdir(exist_ok=True, parents=True)
        rendered = jinja_env.get_template("event.html").render(event=event)
        event_index_file.write_text(rendered)

    print("Done.")


@cli.command()
def sitemap() -> None:
    """Update sitemap.xml"""

    dirs = Dirs.from_env()

    last_modified = {}
    for page in iter_pages(dirs):
        url = page.front_matter.url

        # Fetch last modification date from git. Options:
        # `-1` - Only display the most recent commit message.
        # `--pretty=format:%cI` - Show committer date in strict ISO8601.
        last_modified[url] = subprocess.run(
            ["git", "log", "-1", "--pretty=format:%cI", page.path],
            check=True,
            text=True,
            capture_output=True,
        ).stdout.strip()

    # Build the sitemap
    urlset_node = ET.Element("urlset")
    urlset_node.set("xmlns", "http://www.sitemaps.org/schemas/sitemap/0.9")

    for url, timestamp in last_modified.items():
        url_node = ET.SubElement(urlset_node, "url")
        loc_node = ET.SubElement(url_node, "loc")
        loc_node.text = f"https://onehot.nl{url}"
        lastmod_node = ET.SubElement(url_node, "lastmod")
        lastmod_node.text = timestamp

    # This method is not picked up by mypy / PyCharm, but it does exist.
    ET.indent(urlset_node)  # type: ignore
    (dirs.web / "sitemap.xml").write_bytes(
        ET.tostring(urlset_node, xml_declaration=True, encoding="utf-8")
    )


if __name__ == "__main__":
    cli()

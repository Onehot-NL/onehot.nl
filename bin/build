#!/usr/bin/env python
import functools
import os
import pprint
import shutil
import subprocess
import sys
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Iterator, List, NoReturn, Optional

import jinja2
import typer
from mashumaro import DataClassYAMLMixin
from mashumaro.exceptions import InvalidFieldValue, MissingField

cli = typer.Typer(add_completion=False)


@dataclass
class Dirs:
    root: Path
    web: Path
    build: Path

    @classmethod
    def from_env(cls) -> "Dirs":
        root = Path(os.environ["PROJECT_ROOT"])
        return cls(root=root, web=root / "web", build=root / "ignore" / "dist")


@dataclass
class FrontMatter(DataClassYAMLMixin):
    url: str


@dataclass
class Page(DataClassYAMLMixin):
    path: Path
    front_matter: FrontMatter
    template: str


@dataclass
class Link(DataClassYAMLMixin):
    name: str
    url: str


@dataclass
class Speaker(DataClassYAMLMixin):
    name: str
    affiliation: str
    bio: str
    photograph: str
    external_url: List[Link]


@dataclass
class Talk(DataClassYAMLMixin):
    title: str
    subtitle: str
    speaker: Speaker
    abstract: str
    keywords: str


class EventType(Enum):
    MEETUP = "meetup"


@dataclass
class Event(DataClassYAMLMixin):
    title: str
    type: EventType
    talks: List[Talk]
    date: str
    meetup_url: str
    published: bool


@dataclass
class State(DataClassYAMLMixin):
    events: List[Event]


def load(dirs: Dirs, template_name: str) -> Optional[str]:
    template_file = dirs.web / "templates" / template_name
    if template_file.exists():
        return template_file.read_text()
    else:
        return None


def iter_pages(dirs: Dirs) -> Iterator[Page]:
    for path in (dirs.web / "pages").iterdir():
        front_matter_yaml, template = path.read_text().split("===")
        front_matter = FrontMatter.from_yaml(front_matter_yaml)
        yield Page(path, front_matter, template)


def load_state(dirs: Dirs) -> State:
    events_file = dirs.root / "events.yaml"
    try:
        return State.from_yaml(events_file.read_text())
    except InvalidFieldValue as e:
        pretty_print(events_file.relative_to(dirs.root), e)


def pretty_print(filename: Path, exc: InvalidFieldValue) -> NoReturn:
    # The default exception message is pretty difficult
    # to read. Therefore, walk through the context to find
    # the first exception that was thrown and it's parent
    # so we can print the problem and it's context.
    parent: BaseException = exc
    child: Optional[BaseException] = parent.__context__
    while child and (grandchild := child.__context__) is not None:
        parent = child
        # noinspection PyUnboundLocalVariable
        child = grandchild  # has always been assigned already.

    # With the current Exception hierarchy of `mashumaro`, this
    # will always be the case.
    assert isinstance(parent, InvalidFieldValue)

    # Pretty print errors
    print(f"{filename}: ERROR reading state at:\n")

    field = parent.field_value

    # Lists should be printed at depth 2. Otherwise they
    # show up as `[{...}]`. The rest of the dict should be
    # printed like normal.
    depth = 2 if isinstance(field, list) else 1
    pprint.pp(field, depth=depth)

    # There might be other errors too (e.g. wrong type or
    # failed validation). Will add more here as we find them.
    if isinstance(child, MissingField):
        print(f"\nMissing field '{child.field_name}'")

    # Try to detect the schema and print it if available.
    # `field_type` can be a dataclass, but it could also be
    # a generic type like `List[SomeDataclass]`. Detect what
    # case we're in using some reflection to find out the
    # dataclass fields.
    field_type = parent.field_type
    if hasattr(field_type, "__dataclass_fields__"):
        dcf = field_type.__dataclass_fields__
    elif hasattr(field_type, "__args__"):
        dcf = field_type.__args__[0].__dataclass_fields__
    else:
        dcf = {}

    if dcf:
        print("\nExpected schema:\n")

    for key, field in dcf.items():
        print(f" - {key}: {field.type}")

    sys.exit(1)


@cli.command()
def site() -> None:
    """Build the site"""
    print("Building..")

    dirs = Dirs.from_env()

    shutil.rmtree(dirs.build, ignore_errors=True)
    dirs.build.mkdir(exist_ok=True, parents=True)

    for static in {"style.css", "logo.svg", "sitemap.xml", "robots.txt"}:
        shutil.copy(dirs.web / static, dirs.build)

    for directory in {"img", "font"}:
        shutil.copytree(dirs.web / directory, dirs.build / directory)

    load_fun = functools.partial(load, dirs)
    jinja_env = jinja2.Environment(loader=jinja2.FunctionLoader(load_fun))

    state = load_state(dirs)

    for page in iter_pages(dirs):
        url = page.front_matter.url
        url_dir = dirs.build / url.lstrip("/")
        url_index_file = url_dir / "index.html"

        url_dir.mkdir(exist_ok=True)
        rendered = jinja_env.from_string(page.template).render(
            events=state.events, active_page=url
        )
        url_index_file.write_text(rendered)

    print("Done.")


@cli.command()
def sitemap() -> None:
    """Update sitemap.xml"""

    dirs = Dirs.from_env()

    last_modified = {}
    for page in iter_pages(dirs):
        url = page.front_matter.url

        # Fetch last modification date from git. Options:
        # `-1` - Only display the most recent commit message.
        # `--pretty=format:%cI` - Show committer date in strict ISO8601.
        last_modified[url] = subprocess.run(
            ["git", "log", "-1", "--pretty=format:%cI", page.path],
            check=True,
            text=True,
            capture_output=True,
        ).stdout.strip()

    # Build the sitemap
    urlset_node = ET.Element("urlset")
    urlset_node.set("xmlns", "http://www.sitemaps.org/schemas/sitemap/0.9")

    for url, timestamp in last_modified.items():
        url_node = ET.SubElement(urlset_node, "url")
        loc_node = ET.SubElement(url_node, "loc")
        loc_node.text = f"https://onehot.nl{url}"
        lastmod_node = ET.SubElement(url_node, "lastmod")
        lastmod_node.text = timestamp

    # This method is not picked up by mypy / PyCharm, but it does exist.
    ET.indent(urlset_node)  # type: ignore
    (dirs.web / "sitemap.xml").write_bytes(
        ET.tostring(urlset_node, xml_declaration=True, encoding="utf-8")
    )


if __name__ == "__main__":
    cli()
